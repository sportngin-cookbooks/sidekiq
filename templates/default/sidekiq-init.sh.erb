#!/bin/bash
### BEGIN INIT INFO
# Provides:  sidekiq
# Short-Description: sidekiq - Simple, efficient background processing for Ruby
# Description:  sidekiq - Simple, efficient background processing for Ruby
### END INIT INFO
. /etc/init.d/functions

log_daemon_msg () {
  echo $@
}

LOGFILE="<%= @logfile %>"
SIDEKIQ_CONF="<%= @conf_file %>"
SIDEKIQ_BIN="<%= @bin_file %>"
SIDEKIQ_QUIET_RESTART_BIN="<%= @quiet_restart_bin_file %>"
TIMEOUT="<%= @timeout %>"

# Run a method for each sidekiq worker
#
# Params:
#   $1 (string):  name of the method.  $app and $j are passed in to this method
#   $2 (string):  optional log message
for_each_sidekiq_worker() {
  local pid_start

  # Log a message if one is provided
  if [[ $2 ]]; then log_daemon_msg $2; fi

  pid_start=0
  for i in `cat $SIDEKIQ_CONF`; do
    app=`echo $i | cut -d , -f 1`
    num_workers=`echo $i | cut -d , -f 2`
    for j in `seq $pid_start $(($pid_start + $num_workers - 1))`; do
      $(echo $1) $app $j
    done
    pid_start=$(($j+1))
  done
}

# Start/Restart a single Sidekiq process
do_start_one() {
  local pidfile
  local pid

  pidfile=$1/tmp/pids/$2.pid
  if [ -e $pidfile ]; then
    pid=`cat $pidfile`
    # If Sidekiq isn't running, run it, otherwise restart it.
    if [ "`ps -A -o pid= | grep -c $pid`" -eq 0 ]; then
      do_start_one_do $1 $2
    else
      do_restart_one $1 $2
    fi
  else
    do_start_one_do $1 $2
  fi
}

do_start_one_do() {
  log_daemon_msg "--> Starting Sidekiq $1 - worker $2"
  log_daemon_msg "logging to $1/$LOGFILE"

  app=$1 index=$2 daemon $SIDEKIQ_BIN
  log_daemon_msg "Started Sidekiq $1 - worker $2"
}

#
# Function that stops the daemon/service
#
do_stop_one() {
  local pidfile
  local pid
  log_daemon_msg "--> Stopping Sidekiq $1 - worker $2"

  pidfile=$1/tmp/pids/$2.pid
  if [ -e $pidfile ]; then
    pid=`cat $pidfile`
    if [ "`ps -A -o pid= | grep -c $pid`" -eq 0 ]; then
      log_daemon_msg "---> Sidekiq $1 - worker $2 isn't running."
    else
      log_daemon_msg "---> About to kill PID `cat $pidfile`"
      kill -QUIT $pid
      for i in `seq 1 $TIMEOUT`; do
        checkpid $pid || break
        sleep 1
      done
      if checkpid $pid ; then
        log_daemon_msg "Failed to kill Sidekiq $1 - worker $2 gracefully... hard shut down"
        kill -KILL $pid >/dev/null 2>&1
      fi
      # Many daemons don't delete their pidfiles when they exit.
      rm -f $pidfile
    fi
  else
    log_daemon_msg "---> No Sidekiq $1 - worker $2 here..."
  fi
  return 0
}

#
# Function that restarts the jungle
#
do_restart() {
  for_each_sidekiq_worker "do_restart_one"
}

#
# Function that sends a SIGUSR2 to the daemon/service
#
do_restart_one() {
  local pidfile
  local pid

  pidfile=$1/tmp/pids/$2.pid
  if [ -e $pidfile ]; then
    pid=`cat $pidfile`
    log_daemon_msg "--> About to restart Sidekiq $1 - worker $2"
    do_stop_one $1 $2
    do_start_one_do $1 $2
  else
    log_daemon_msg "--> Sidekiq was not running... Starting"
    do_start_one_do $1 $2
  fi
  return 0
}

#
# Function that runs the quiet-restart script on a single worker
#
do_quiet_restart() {
<% if @background_quiet_restart %>
  app=$1 index=$2 daemon $SIDEKIQ_QUIET_RESTART_BIN
<% else %>
  app=$1 index=$2 $SIDEKIQ_QUIET_RESTART_BIN
<% end %>
}

start() {
  for_each_sidekiq_worker "do_start_one" "=> Starting Sidekiq workers..."
}

stop() {
  for_each_sidekiq_worker "do_stop_one" "=> Stopping all Sidekiq workers"
}

quiet_restart() {
  for_each_sidekiq_worker "do_quiet_restart" "=> Beginning quiet restart of all Sidekiq workers"
}

case "$1" in
  start) start ;;
  stop) stop ;;
  restart)
    stop
    start
    ;;
  quiet_restart)
    quiet_restart
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|quiet_restart}" >&2
    exit 1
    ;;
esac
